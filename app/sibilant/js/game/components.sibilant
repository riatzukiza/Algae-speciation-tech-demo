(macro percent-of (container)
       `(/ (get @container 'value) (get @container 'max)))
(macro include-module (path)
       `(include (+ @path "/index")))

(include-module "./components/templates")


(include "./components/natural-healing")



(type Organic )


;; life needs calories to exist, if this number hits zero, bad things happen.
;; in the near term, this means it dies, but it may instaed start to damage its
;; self to gain more calories until it looses all ofits health

;; (the flesh of the organisim is its self a source of calories.)


(include "./components/containers"
         "./components/absorbers.sibilant")



(percent-of {value 50 max 100 })

(macro sprint (val) `(print (quote @val) @val))






(type Living )
(describe Living
          (cost 0)
          (init (entity))
          (gmth update (entity passive-costs active-costs)))

(macro component-of (e comp)
       `(get @e (get @comp 'symbol))
       )

(def prob-prod (arr)
  (.reduce arr (=> (v comp) (* v (percent-of comp))) 1))

(macro require-components (ent vars ...body)
       `(let (...@(.map vars.contents (=> (v) `(@v (component-of @ent @v)))))
          ...@body))

(macro if! (cond ...body)
       `(state if @cond  ...@(interleave ";\n" body)))
(def reduce-until  (matrix cond f value)

  (var break? false)
  (loop
     (for-up-to x matrix.width
                (if! break? break))
     (for-up-to y matrix.height

                (var cell (.get matrix x y))
                (assign value (f value cell x y matrix))

                (if! (cond value cell x y matrix)
                     (assign break? true) break)))
  value)


(def decide (random) (=> ([counter]) (>= counter random)))
(def increment-counter ([counter ] p x y) [(+ counter p) x y])
(def select-random-location (matrix)

  (var total (.convolve count-kernel matrix)
       prob (.map  matrix (=> (v) (/ v total)))
       )
  (rest (reduce-until prob (decide (Math.random)) increment-counter [0 0 0 ])))

(var self-exclusion-kernel
     (matrix 3 3
             [

             1 1 1
             1 1 1
             1 1 1

             ])
     )
(def-lit-macro def (name args ...body)
  `(mth @name @args ...@body))

(def-lit-macro def-generic (name args ...body)
  `(gmth @name @args ...@body))

(type Probability-space )

(def last-of (arr) (last arr))



(macro define-type (name args ...body)
  (if (dotted? name)
      (let* ((dashed-tokens (.split name.token "."))
             (type-name (last-of dashed-tokens)))
        `(assign @name))))
(var conditional-probability prob-prod)

(describe Probability-space

          (init (matrix))

          (gett total (.convolve count-kernel matrix))
          (gett prob (.map  matrix (=> (v) (/ v this.total))))

          (def joint (probs)
            (.reduce probs mult (identity)))

          (def-generic random-location (prob)

            (rest (reduce-until prob (decide (Math.random)) increment-counter [0 0 0 ]))))

(def find (ent-coord-part c)
  (mod (+ ent-coord-part -1 (if (<= c 0) (+ c 100) c)) 100))


(def-curried local-joint-probability ( prob field entity)
  (let (( location (.get field entity.x entity.y)))
    (.mult prob location)))

(def mult ( a b) (.mult a b))


(def-curried local-joint-of (arr entity)
  (.reduce arr (local-joint-probability entity) (identity)))

(def random-neighbor ()
  (pipe (local-joint-of [Water Light Silt])
        (Probability-space.random-location)))

(type Mitosis )
(describe Mitosis

          (init (entity ))
          (def-generic divide (entity (loc (random-neighbor)))
            "attempt to create a new instance of the entity at a "
            (create-instance-of Algae (find entity.x (first loc)) (find entity.y (second loc))))

          (def-generic update (entity prob)
            "choose randomly a cell to divide into, biased against total amount of available resources in all locations around the cell"
            (require-components
             entity

             (Health
              Hydration
              Calories
              Nutriants)
             ;;(print Health Nutriants Calories Hydration)

             (let ((chance-to-divide (prob-prod [Health Hydration Calories Nutriants]))
                   (random (Math.random)))
               ;;(print "chance to divide" chance-to-divide)

               (if (>  (* 0.3 chance-to-divide) random)

                   (.attempt-to-divide))))))


